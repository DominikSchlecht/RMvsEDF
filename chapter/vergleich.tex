\subsection{Implementation Complexity}
\begin{frame}{\subsecname}
	Frage:
	\begin{itemize}
		\item Wie groß ist der Aufwand das Scheduling-Verfahren zu implementieren?
	\end{itemize}
	Antwort:
	\begin{itemize}
		\item Rate Monotonics ist einfacher zu implementieren!
	\end{itemize}
\end{frame}

\begin{frame}{\subsecname}
	Ist es so einfach?\\\pause
	Faktoren:
	\begin{itemize}
		\item Wird auf einem bestehenden System entwickelt?
		\item Sind die Prioritäten festgesetzt oder können diese während der Laufzeit verändert werden?
		\item Wie viele Prioritäts-Level gibt es? %TODO Beispiel?
	\end{itemize}
\end{frame}

\begin{frame}{\subsecname}
	Annahme
	\begin{itemize}
		\item Das System wird von Grund auf mit einer Ready-Qeue implementiert\pause
		\item In dieser werden die Tasks für Rate Monotonics
			\begin{itemize}
				\item absteigend nach nach den Proritäten-Leveln
			\end{itemize}
			und für Erliest Deadline First
			\begin{itemize}
				\item aufsteigend nach der absoluten Deadline
			\end{itemize} gespeichert.
	\end{itemize}
\end{frame}

\input{chapter/vergleich/RuntimeOverhead.tex}

\subsection{Schedulability Analysis}
\begin{frame}{\subsecname}
	%TODO
\end{frame}

\input{chapter/vergleich/RobustnessDuringOverloads.tex}

\subsection{Jitter and Latency}

\begin{frame}{\subsecname}
	Definition von Jitter:\\
	Absolute Response Time Jitter $ARJ_i$ ist definiert durch
	\begin{equation}
		ARJ_i=max R_{i,k}-min R_{i,k}
	\end{equation} mit
	$R_{i,K}$ als Response-Time für den $k$-ten Job von $\uptau_i$
\end{frame}

\begin{frame}{\subsecname}
	Vorurteil:
	\begin{itemize}
		\item Durch die festen Prioritäten entsteht währen der Laufzeit bei Rate Monotonics weniger Jitter als bei Erliest Deadline First. 
	\end{itemize}
\end{frame}

\newcommand{\showRMSlideJit}[1] {\begin{frame}{Beispiel Jitter Rate Monotonics}
		\begin{center}
		\begin{tabular}{c||c|c}
			Task ($\uptau_i$) & Dauer ($C_i$) & Task-Periode ($T_i$)\\\hline\hline
			$\uptau_1$ & 2 & 6\\
			$\uptau_2$ & 3 & 8\\
			$\uptau_3$ & 2 & 12
		\end{tabular}
	\end{center}
	\input{graphics/vergleich/jitter#1_RM.tex}
\end{frame}}

\forloop{ct}{1}{\value{ct} < 5}%
{%
	\showRMSlideJit{\arabic{ct}}
}

\begin{frame}{Beispiel Jitter Erliest Deadline First}
		\begin{center}
		\begin{tabular}{c||c|c}
			Task ($\uptau_i$) & Dauer ($C_i$) & Task-Periode ($T_i$)\\\hline\hline
			$\uptau_1$ & 2 & 6\\
			$\uptau_2$ & 3 & 8\\
			$\uptau_3$ & 2 & 12
		\end{tabular}
	\end{center}
	\input{graphics/vergleich/jitter1_EDF.tex}
\end{frame}

\begin{frame}{\subsecname}
	\begin{center}
		\includegraphics[scale=.25]{graphics/vergleich/jitter.png}	
	\end{center}
\end{frame}

\begin{frame}{\subsecname}
	Fazit:
	\begin{itemize}
		\item RM hält Jitter für die hoch priorisierten Tasks sehr niedrig, vernachlässigt jedoch die anderen Tasks
		\item Insgesamt erzeugt EDF, gerade bei hoher Auslastung, wesentlich weniger Jitter
	\end{itemize}
\end{frame}

\subsection{Other Issues}
\subsubsection{Ressource Sharing}
\begin{frame}{\subsubsecname}
	Test
\end{frame}

\subsubsection{Aperiodic Task Handling}
\begin{frame}{\subsubsecname}
	Test
\end{frame}

\subsubsection{Ressource Reservation}
\begin{frame}{\subsubsecname}
	Test
\end{frame}